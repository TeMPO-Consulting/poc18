from odoo import api, fields, models


class ProductProduct(models.Model):
    _name = "product.product"
    _description = "Product"
    _inherits = {'product.template': 'product_tmpl_id'}
    _order = 'default_code,name_template'

    qty_available = fields.Float(string="Real Stock", compute="_product_available", digits=(16, 3), readonly=True,
                                 help="Current quantities of products in selected locations or all internal if none have been selected.")
    virtual_available = fields.Float(string="Virtual Stock", compute="_product_available", digits=(16, 3),
                                     readonly=True,
                                     help="Future stock for this product according to the selected locations or all internal if none have been selected. Computed as: Real Stock - Outgoing + Incoming.")
    incoming_qty = fields.Float(string="Incoming", compute="_product_available", digits=(16, 3), readonly=True,
                                help="Quantities of products that are planned to arrive in selected locations or all internal if none have been selected.")
    outgoing_qty = fields.Float(string="Outgoing", compute="_product_available", digits=(16, 3), readonly=True,
                                help="Quantities of products that are planned to leave in selected locations or all internal if none have been selected.")
    price = fields.Float(string="Pricelist", compute="_product_price", digits=(16, 2), readonly=True)
    lst_price = fields.Float(string="Public Price", compute="_product_lst_price", digits=(16, 2), readonly=True)
    code = fields.Char(string="Reference", compute="_product_code", readonly=True)
    partner_ref = fields.Char(string="Customer ref", compute="_product_partner_ref", readonly=True)
    default_code = fields.Char(string="Code", size=18)
    active = fields.Boolean(string="Active",
                            help="If the active field is set to False, it will allow you to hide the product without removing it.",
                            default=lambda *a: True, )
    variants = fields.Char(string="Variants", size=64)
    product_tmpl_id = fields.Many2one(string="Product Template", comodel_name="product.template", required=True, ondelete="cascade")
    ean13 = fields.Char(string="EAN13", size=13)
    # packaging = fields.One2many(string="Logistical Units", comodel_name="product.packaging", inverse_name="product_id",
    #                             help="Gives the different ways to package the same product. This has no impact on the picking order and is mainly used if you use the EDI module.")
    price_extra = fields.Float(string="Variant Price Extra", digits=(16, 2), default=0.0)
    price_margin = fields.Float(string="Variant Price Margin", digits=(16, 2), default=1.0)
    # pricelist_id = fields.Many2one(string="Pricelist", comodel_name="product.pricelist")
    name_template = fields.Char(related="product_tmpl_id.name")
    expected_prod_creator = fields.Boolean(string="Expected Product Creator for Product Mass Update",
                                           compute="_get_expected_prod_creator", search="_expected_prod_creator_search",
                                           readonly=True)
    qty_reserved = fields.Float(string="Reserved Qty", compute="_product_available", digits=(16, 3), readonly=True)
    qty_allocable = fields.Float(string="Available Qty", compute="_product_available", digits=(16, 3), readonly=True,
                                 help="Real stock - reserved stock")
    track_production = fields.Boolean(string="Track Manufacturing Lots",
                                      help="Forces to specify a Production Lot for all moves containing this product and generated by a Manufacturing Order")
    track_incoming = fields.Boolean(string="Track Incoming Lots",
                                    help="Forces to specify a Production Lot for all moves containing this product and coming from a Supplier Location")
    track_outgoing = fields.Boolean(string="Track Outgoing Lots",
                                    help="Forces to specify a Production Lot for all moves containing this product and going to a Customer Location")
    # location_id = fields.Many2one(string="Stock Location", comodel_name="stock.location")
    valuation = fields.Selection(string="Inventory Valuation", selection=[('manual_periodic', 'Periodical (manual)'),
                                                                          ('real_time', 'Real Time (automated)')],
                                 required=True,
                                 help="If real-time valuation is enabled for a product, the system will automatically "
                                      "write journal entries corresponding to stock moves.The inventory variation "
                                      "account set on the product category will represent the current inventory value, "
                                      "and the stock input and stock output account will hold the counterpart moves for"
                                      " incoming and outgoing products.",
                                 default='manual_periodic')
    manufacturer = fields.Many2one(string="Manufacturer", comodel_name="res.partner")
    manufacturer_pname = fields.Char(string="Manufacturer Product Name", size=64)
    manufacturer_pref = fields.Char(string="Manufacturer Product Code", size=64)
    # attribute_ids = fields.One2many(string="Attributes", comodel_name="product.manufacturer.attribute",
    #                                 inverse_name="product_id")
    life_time = fields.Integer(string="Product Life Time",
                               help="The number of months before a production lot may become dangerous and should not be consumed.")
    use_time = fields.Integer(string="Product Use Time",
                              help="The number of months before a production lot starts deteriorating without becoming dangerous.")
    removal_time = fields.Integer(string="Product Removal Time",
                                  help="The number of months before a production lot should be removed.")
    alert_time = fields.Integer(string="Product Alert Time",
                                help="The number of months after which an alert should be notified about the production lot.")
    # donation_expense_account = fields.Many2one(string="Donation Account", comodel_name="account.account")
    fnct_categ_id = fields.Many2one(string="Category", compute="_get_categ", search="_search_categ",
                                    comodel_name="product.category", readonly=True)
    # list_ids = fields.Many2many(string="Lists", compute="_get_list_sublist", search="_search_list_sublist",
    #                             comodel_name="product.list", readonly=True)
    msfid = fields.Integer(string="MSFID", help="Hidden field for UniData")
    xmlid_code = fields.Char(string="Xmlid Code", size=18)
    sdref = fields.Char(string="SDref", compute="_get_sdref", search="_search_sdref", size=256, readonly=True)
    duplicate_ok = fields.Boolean(string="Is a duplicate", default=True)
    loc_indic = fields.Char(string="Indicative Location", size=64)
    description2 = fields.Text(string="Description 2")
    old_code = fields.Char(string="Old code", size=1024)
    new_code = fields.Char(string="New code", size=64)
    # international_status = fields.Many2one(string="Product Creator", comodel_name="product.international.status")
    int_status_code = fields.Char(string="Code of Product Creator", compute="_get_int_status_code", size=64,
                                  readonly=True)
    perishable = fields.Boolean(string="Expiry Date Mandatory", default=False)
    batch_management = fields.Boolean(string="Batch Number Mandatory", default=False)
    batch_attributes = fields.Selection(string="Batch Attr.", compute="_get_batch_attributes",
                                        search="_search_batch_attributes",
                                        selection=[('no', 'X'), ('bn', 'BN+ED'), ('ed', 'ED only')], readonly=True)
    product_catalog_page = fields.Char(string="Product Catalog Page", size=64)
    product_catalog_path = fields.Char(string="Product Catalog Path", size=1024)
    is_ssl = fields.Boolean(string="Is Short Shelf Life ?", compute="_compute_kc_dg_cs_ssl_values", store=True,
                            readonly=True)
    ssl_txt = fields.Char(string="Short Shelf Life icon", compute="_compute_kc_dg_cs_ssl_values", store=True, size=8,
                          readonly=True)
    short_shelf_life = fields.Selection(string="Short Shelf Life",
                                        selection=[('False', 'No'), ('True', 'Yes'), ('no_know', 'tbd')], required=True,
                                        default="False")
    criticism = fields.Selection(string="Criticality",
                                 selection=[('', ''), ('exceptional', '1-Exceptional'), ('specific', '2-Specific'),
                                            ('important', '3-Important'), ('medium', '4-Medium'),
                                            ('common', '5-Common'), ('other', 'X-Other')])
    narcotic = fields.Boolean(string="Narcotic/Psychotropic", default=False)
    abc_class = fields.Selection(string="ABC Class", selection=[('', ''), ('a', 'A'), ('b', 'B'), ('c', 'C')])
    # section_code_ids = fields.Many2many(string="Section Code", comodel_name="product.section.code",
    #                                     relation="product_section_code_rel", column1="product_id",
    #                                     column2="section_code_id")
    library = fields.Selection(string="Library",
                               selection=[('', ''), ('l1', 'L1'), ('l2', 'L2'), ('l3', 'L3'), ('l4', 'L4')])
    # supply_source_ids = fields.Many2many(string="Supply Source", comodel_name="product.supply.source",
    #                                      relation="product_supply_source_rel", column1="product_id",
    #                                      column2="supply_source_id")
    sublist = fields.Char(string="Sublist", size=64)
    composed_kit = fields.Boolean(string="Kit Composed of Kits/Modules", default=False)
    options_ids = fields.Many2many(string="Options", comodel_name="product.product", relation="product_options_rel",
                                   column1="product_id", column2="product_option_id")
    is_kc = fields.Boolean(string="Is Cold Chain ?", compute="_compute_kc_dg_cs_ssl_values", store=True, readonly=True)
    # heat_sensitive_item = fields.Many2one(string="Temperature sensitive item", comodel_name="product.heat_sensitive",
    #                                       required=True)
    # cold_chain = fields.Many2one(string="Thermosensitivity", comodel_name="product.cold_chain")
    show_cold_chain = fields.Boolean(string="Show cold chain")
    options_ids_inv = fields.Many2many(string="Options Inv.", comodel_name="product.product",
                                       relation="product_options_rel", column1="product_option_id",
                                       column2="product_id")
    sterilized = fields.Selection(string="Sterile", selection=[('yes', 'Yes'), ('no', 'No'), ('no_know', 'tbd')],
                                  required=True, default="no")
    single_use = fields.Selection(string="Single Use", selection=[('yes', 'Yes'), ('no', 'No'), ('no_know', 'tbd')],
                                  required=True, default="no")
    # justification_code_id = fields.Many2one(string="Justification Code", comodel_name="product.justification.code")
    med_device_class = fields.Selection(string="Medical Device Class",
                                        selection=[('', ''), ('I', 'Class I (General controls)'),
                                                   ('II', 'Class II (General control with special controls)'),
                                                   ('III', 'Class III (General controls and premarket)')])
    manufacturer_txt = fields.Text(string="Manufacturer")
    manufacturer_ref = fields.Char(string="Manufacturer Ref.", size=1024)
    closed_article = fields.Selection(string="Closed Article",
                                      selection=[('yes', 'Yes'), ('no', 'No'), ('recommanded', 'Recommended')],
                                      required=True, default="no")
    is_dg = fields.Boolean(string="Is a Dangerous Goods ?", compute="_compute_kc_dg_cs_ssl_values", store=True,
                           readonly=True)
    dg_txt = fields.Char(string="Dangerous Goods icon", compute="_compute_kc_dg_cs_ssl_values", store=True, size=8,
                         readonly=True)
    dangerous_goods = fields.Selection(string="Dangerous goods",
                                       selection=[('False', 'No'), ('True', 'Yes'), ('no_know', 'tbd')], required=True,
                                       default="False")
    restricted_country = fields.Boolean(string="Restricted in the Country", default=False)
    # country_restriction = fields.Many2one(string="Country Restriction", comodel_name="res.country.restriction")
    state_ud = fields.Selection(string="UniData Status", selection=[('valid', 'Valid'), ('outdated', 'Outdated'),
                                                                    ('discontinued', 'Discontinued'),
                                                                    ('phase_out', 'Phase Out'), ('stopped', 'Stopped'),
                                                                    ('archived', 'Archived'),
                                                                    ('forbidden', 'Forbidden')], readonly=True,
                                help="Automatically filled with UniData information.")
    golden_status = fields.Selection(string="UD Golden State",
                                     selection=[('Golden', 'Golden'), ('Unmatched', 'Unmatched'), ('Merged', 'Merged'),
                                                ('Deleted', 'Deleted')], readonly=True)
    is_ud_golden = fields.Boolean(string="UD Golden", compute="_get_is_ud_golden", search="_search_is_ud_golden",
                                  readonly=True)
    ud_seen = fields.Boolean(string="UD seen in last full sync", readonly=True)
    oc_subscription = fields.Boolean(string="OC Subscription", default=False)
    un_code = fields.Char(string="UN Code", size=32)
    hs_code = fields.Char(string="HS Code", size=12, readonly=True)
    gmdn_code = fields.Char(string="GMDN Code", size=5)
    gmdn_description = fields.Char(string="GMDN Description", size=64)
    currency_id = fields.Many2one(string="Currency", comodel_name="res.currency", readonly=True,
                                  default=lambda self: self.env.company.currency_id)
    field_currency_id = fields.Many2one(string="Currency", comodel_name="res.currency", readonly=True,
                                        default=lambda self: self.env.company.currency_id)
    nomen_ids = fields.Many2many(string="Nomenclatures", compute="_get_nomen", search="_search_nomen",
                                 comodel_name="product.nomenclature", readonly=True)
    controlled_substance = fields.Selection(string="Controlled substance",
                                            selection=[('!', '! - Requires national export license'),
                                                       ('N1', 'N1 - Narcotic 1'), ('N2', 'N2 - Narcotic 2'),
                                                       ('P1', 'P1 - Psychotrop 1'), ('P2', 'P2 - Psychotrop 2'),
                                                       ('P3', 'P3 - Psychotrop 3'), ('P4', 'P4 - Psychotrop 4'),
                                                       ('DP', 'DP - Drug Precursor'),
                                                       ('Y', 'Y - Kit or module with controlled substance'), ('True',
                                                                                                              'CS / NP - Controlled Substance / Narcotic / Psychotropic')],
                                            default=False)
    is_cs = fields.Boolean(string="Is Controlled subst.", compute="_compute_kc_dg_cs_ssl_values", store=True,
                           readonly=True)
    cs_txt = fields.Char(string="Controlled subst. icon", compute="_compute_kc_dg_cs_ssl_values", store=True, size=8,
                         readonly=True)
    uom_category_id = fields.Many2one(string="Uom Category", related="uom_id.category_id",
                                      comodel_name="uom.category", readonly=True)
    no_external = fields.Boolean(string="External partners orders", compute="_get_restriction", store=True,
                                 readonly=True)
    no_esc = fields.Boolean(string="ESC partners orders", compute="_get_restriction", store=True, readonly=True)
    no_internal = fields.Boolean(string="Internal partners orders", compute="_get_restriction", store=True,
                                 readonly=True)
    no_consumption = fields.Boolean(string="Comsumption", compute="_get_restriction", store=True, readonly=True)
    no_storage = fields.Boolean(string="Storage", compute="_get_restriction", store=True, readonly=True)
    available_for_restriction = fields.Boolean(string="Available for the partner", compute="_get_dummy",
                                               search="_src_available_for_restriction", readonly=True)
    form_value = fields.Text(string="Form", translate=True)
    fit_value = fields.Text(string="Fit", translate=True)
    function_value = fields.Text(string="Function", translate=True)
    standard_ok = fields.Selection(string="Standardization Level",
                                   selection=[('standard', 'Standard'), ('non_standard', 'Non-standard'),
                                              ('non_standard_local', 'Non-standard Local')], required=True,
                                   default="non_standard")
    local_from_hq = fields.Boolean(string="Non-Standard Local from HQ", compute="_get_local_from_hq", readonly=True,
                                   help="Set to True when HQ generates a sync update on NSL product")
    level_source = fields.Char(string="Instance level which has generated the sync update",
                               compute="_get_local_from_hq", readonly=True)
    local_activation_from_merge = fields.Boolean(string="Non-Standard Local from COO",
                                                 compute="_get_local_activation_from_merge", readonly=True,
                                                 help="Activate on COO from merge")
    active_change_date = fields.Datetime(string="Date of last active change", readonly=True)
    active_sync_change_date = fields.Datetime(string="Date of last active sync change", readonly=True)
    soq_weight = fields.Float(string="SoQ Weight", digits=(16, 5))
    soq_volume = fields.Float(string="SoQ Volume", digits=(16, 5))
    soq_quantity = fields.Float(string="SoQ Quantity", digits=(16, 2),
                                help="Standard Ordering Quantity. Quantity according to which the product should be ordered. The SoQ is usually determined by the typical packaging of the product.")
    # vat_ok = fields.Boolean(string="VAT OK", compute="_get_vat_ok", readonly=True,
    #                         default=lambda obj, cr, uid, c: obj.pool.get('unifield.setup.configuration').get_config(cr,
    #                                                                                                                 uid).vat_ok, )
    nsl_merged = fields.Boolean(string="UD / NSL merged", compute="_get_nsl_merged", readonly=True)
    replace_product_id = fields.Many2one(string="Merged from", comodel_name="product.product")
    replaced_by_product_id = fields.Many2one(string="Merged to", comodel_name="product.product")
    allow_merge = fields.Boolean(string="UD Allow merge", compute="_get_allow_merge", readonly=True)
    uf_write_date = fields.Datetime(string="Write date")
    uf_create_date = fields.Datetime(string="Creation date")
    instance_level = fields.Char(string="Instance Level", compute="_get_product_instance_level", readonly=True)
    show_ud = fields.Boolean(string="Search UD NSL or ST/NS", compute="_get_dummy", search="_search_show_ud",
                             readonly=True)
    currency_fixed = fields.Boolean(string="Currency Changed by US-8196")
    can_be_hq_merged = fields.Boolean(string="Can this product be merged to a kept product ?",
                                      compute="_get_can_be_hq_merged", readonly=True)
    kept_product_id = fields.Many2one(string="Kept Product", comodel_name="product.product", readonly=True)
    kept_initial_product_id = fields.Many2one(string="1st Kept Product in case of chaining",
                                              comodel_name="product.product", readonly=True)
    unidata_merged = fields.Boolean(string="UniData Merged", readonly=True)
    unidata_merge_date = fields.Datetime(string="Date of UniData Merge", readonly=True)
    is_kept_product = fields.Boolean(string="Is a kept product", readonly=True)
    oc_validation = fields.Boolean(string="OC Validation", readonly=True)
    oc_validation_date = fields.Datetime(string="Validation Date", readonly=True)
    oc_devalidation_date = fields.Datetime(string="Devalidation Date", readonly=True)
    oc_devalidation_reason = fields.Text(string="Devalidation Reason", readonly=True)
    oc_comments = fields.Text(string="Use Comments", readonly=True)
    # oc_project_restrictions = fields.Many2many(string="UD Project Restrictions", comodel_name="unidata.project",
    #                                            relation="product_project_rel", column1="product_id",
    #                                            column2="unidata_project_id", readonly=True)
    # oc_country_restrictions = fields.Many2many(string="UD Country Restrictions", comodel_name="unidata.country",
    #                                            relation="product_country_rel", column1="product_id",
    #                                            column2="unidata_country_id", readonly=True)
    # oc_instance_restrictions = fields.Many2many(string="Project Restrictions", compute="_get_oc_coordo_restrictions",
    #                                             comodel_name="msf.instance", readonly=True)
    # oc_coordo_restrictions = fields.Many2many(string="Mission Restrictions", compute="_get_oc_coordo_restrictions",
    #                                           comodel_name="msf.instance", readonly=True)
    # msl_project_ids = fields.Many2many(string="MSL List", comodel_name="unifield.instance", relation="product_msl_rel",
    #                                    column1="product_id", column2="unifield_instance_id", readonly=True)
    restrictions_txt = fields.Text(string="Restrictions", compute="_get_restrictions_txt", readonly=True)
    mml_status = fields.Selection(string="MML", compute="_get_std_mml_status",
                                  selection=[('T', 'Yes'), ('F', 'No'), ('na', '')], readonly=True, default="na")
    msl_status = fields.Selection(string="MSL", compute="_get_std_mml_status",
                                  selection=[('T', 'Yes'), ('F', 'No'), ('na', '')], readonly=True, default="na")
    # in_mml_instance = fields.Many2one(string="MML Valid for instance", compute="get_fake", comodel_name="msf.instance",
    #                                   readonly=True, domain="[('state', '=', 'active'), ('level', '!=', 'section')]")
    # mml_restricted_instance = fields.Many2one(string="MML Restricted to instance", compute="get_fake",
    #                                           comodel_name="msf.instance", readonly=True,
    #                                           domain="[('state', '=', 'active'), ('level', '!=', 'section')]")
    # in_msl_instance = fields.Many2many(string="MSL Valid for instance", compute="_get_valid_msl_instance",
    #                                    comodel_name="unifield.instance", readonly=True,
    #                                    domain="[('uf_active', '=', True)]")
    incompatible_oc_default_values = fields.Boolean(string="Incompatible OC default", compute="get_fake",
                                                    search="_search_incompatible_oc_default_values", readonly=True)
    procure_delay = fields.Float(string="Procurement Lead Time", digits=(16, 2),
                                 help="It's the default time to procure this product. This lead time will be used on the Order cycle procurement computation",
                                 default=60)
    monthly_consumption = fields.Float(string="Real Consumption", compute="compute_mac", digits=(16, 2), readonly=True)
    product_amc = fields.Float(string="Monthly consumption", compute="_compute_product_amc", digits=(16, 2),
                               readonly=True)
    reviewed_consumption = fields.Float(string="Forecasted Monthly Consumption", compute="_compute_fmc", digits=(16, 2),
                                        readonly=True)
    # catalogue_ids = fields.Many2many(string="Catalogues", compute="_get_catalogue_ids", search="_search_catalogue_ids",
    #                                  comodel_name="supplier.catalogue", readonly=True)
    purchase_type = fields.Boolean(string="Purchase type", compute="_get_purchase_type", search="_src_purchase_type",
                                   readonly=True)
    # asset_ids = fields.One2many(string="Assets", comodel_name="product.asset", inverse_name="product_id")
    has_active_completed_theo_kit_kit = fields.Boolean(string="Kit and completed theoretical list",
                                                       compute="_vals_get_kit", search="_search_completed_kit",
                                                       readonly=True)
    # prodlot_ids = fields.One2many(string="Batch Numbers", comodel_name="stock.production.lot",
    #                               inverse_name="product_id")
    transport_ok = fields.Boolean(string="Transport product",
                                  help="Check this box if the current product is a transport product.")
    picking_ids = fields.Boolean(string="Picking", compute="_vals_get_claim", search="_search_picking_claim",
                                 readonly=True)
    import_product_qty = fields.Float(string="Qty", compute="_get_import_product_qty", inverse="_write_imp_product_qty",
                                      digits=(16, 2))

    # Compute methods
    def _product_available(self):
        """"""
        for record in self:
            record.qty_available = 0.0
            record.virtual_available = 0.0
            record.incoming_qty = 0.0
            record.outgoing_qty = 0.0
            record.qty_reserved = 0.0
            record.qty_allocable = 0.0

    def _product_price(self):
        """"""
        for record in self:
            record.price = 0.0

    def _product_lst_price(self):
        """"""
        for record in self:
            record.lst_price = 0.0

    def _product_code(self):
        """"""
        for record in self:
            record.code = ""

    def _product_partner_ref(self):
        """"""
        for record in self:
            record.partner_ref = ""

    def _get_expected_prod_creator(self):
        """"""
        for record in self:
            record.expected_prod_creator = False

    def _get_categ(self):
        """"""
        for record in self:
            record.fnct_categ_id = None

    def _get_list_sublist(self):
        """"""
        for record in self:
            record.list_ids = None

    def _get_sdref(self):
        """"""
        for record in self:
            record.sdref = ""

    def _get_int_status_code(self):
        """"""
        for record in self:
            record.int_status_code = ""

    def _get_batch_attributes(self):
        """"""
        for record in self:
            record.batch_attributes = ""

    #@api.depends('')
    def _compute_kc_dg_cs_ssl_values(self):
        """"""
        for record in self:
            record.is_ssl = False
            record.ssl_txt = ""
            record.is_kc = False
            record.is_dg = False
            record.dg_txt = ""
            record.is_cs = False
            record.cs_txt = ""

    def _get_is_ud_golden(self):
        """"""
        for record in self:
            record.is_ud_golden = False

    def _get_nomen(self):
        """"""
        for record in self:
            record.nomen_ids = None

    #@api.depends('')
    def _get_restriction(self):
        """"""
        for record in self:
            record.no_external = False
            record.no_esc = False
            record.no_internal = False
            record.no_consumption = False
            record.no_storage = False

    def _get_dummy(self):
        """"""
        for record in self:
            record.available_for_restriction = False
            record.show_ud = False

    def _get_local_from_hq(self):
        """"""
        for record in self:
            record.local_from_hq = False
            record.level_source = ""

    def _get_local_activation_from_merge(self):
        """"""
        for record in self:
            record.local_activation_from_merge = False

    def _get_vat_ok(self):
        """"""
        for record in self:
            record.vat_ok = False

    def _get_nsl_merged(self):
        """"""
        for record in self:
            record.nsl_merged = False

    def _get_allow_merge(self):
        """"""
        for record in self:
            record.allow_merge = False

    def _get_product_instance_level(self):
        """"""
        for record in self:
            record.instance_level = ""

    def _get_can_be_hq_merged(self):
        """"""
        for record in self:
            record.can_be_hq_merged = False

    def _get_oc_coordo_restrictions(self):
        """"""
        for record in self:
            record.oc_instance_restrictions = None
            record.oc_coordo_restrictions = None

    def _get_restrictions_txt(self):
        """"""
        for record in self:
            record.restrictions_txt = ""

    def _get_std_mml_status(self):
        """"""
        for record in self:
            record.mml_status = ""
            record.msl_status = ""

    def get_fake(self):
        """"""
        for record in self:
            record.in_mml_instance = None
            record.mml_restricted_instance = None
            record.incompatible_oc_default_values = False

    def _get_valid_msl_instance(self):
        """"""
        for record in self:
            record.in_msl_instance = None

    def compute_mac(self):
        """"""
        for record in self:
            record.monthly_consumption = 0.0

    def _compute_product_amc(self):
        """"""
        for record in self:
            record.product_amc = 0.0

    def _compute_fmc(self):
        """"""
        for record in self:
            record.reviewed_consumption = 0.0

    def _get_catalogue_ids(self):
        """"""
        for record in self:
            record.catalogue_ids = None

    def _get_purchase_type(self):
        """"""
        for record in self:
            record.purchase_type = False

    def _vals_get_kit(self):
        """"""
        for record in self:
            record.has_active_completed_theo_kit_kit = False

    def _vals_get_claim(self):
        """"""
        for record in self:
            record.picking_ids = False

    def _get_import_product_qty(self):
        """"""
        for record in self:
            record.import_product_qty = 0.0

    # Search methods
    def _search_categ(self, operator, value):
        """"""
        return [('id', operator, value)]

    def _search_nomen(self, operator, value):
        """"""
        return [('id', operator, value)]

    def _search_catalogue_ids(self, operator, value):
        """"""
        return [('id', operator, value)]

    def _src_purchase_type(self, operator, value):
        """"""
        return [('id', operator, value)]

    def _search_batch_attributes(self, operator, value):
        """"""
        return [('id', operator, value)]

    def _search_sdref(self, operator, value):
        """"""
        return [('id', operator, value)]

    def _search_list_sublist(self, operator, value):
        """"""
        return [('id', operator, value)]

    def _src_available_for_restriction(self, operator, value):
        """"""
        return [('id', operator, value)]

    def _search_show_ud(self, operator, value):
        """"""
        return [('id', operator, value)]

    def _search_incompatible_oc_default_values(self, operator, value):
        """"""
        return [('id', operator, value)]

    def _search_completed_kit(self, operator, value):
        """"""
        return [('id', operator, value)]

    def _expected_prod_creator_search(self, operator, value):
        """"""
        return [('id', operator, value)]

    def _search_is_ud_golden(self, operator, value):
        """"""
        return [('id', operator, value)]

    def _search_picking_claim(self, operator, value):
        """"""
        return [('id', operator, value)]

    # Inverse methods
    def _write_imp_product_qty(self):
        """"""
        pass
